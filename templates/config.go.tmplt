package {{.Name}}

import (
	"crypto/tls"
	"crypto/x509"
	"google.golang.org/grpc/credentials"
	"gopkg.in/yaml.v2"
	"log"
	"os"
	"io/ioutil"
)

type ServerConfig struct {
	ListenAddr string `yaml:"listen_on"`
	DatabaseURI string `yaml:"db_uri"`

	MaxMessageSizeBytes int `yaml:"max_message_size_bytes"`

	// SentryDSN string `yaml:"sentry_dsn"`

	ServerCert string `yaml:"server_cert"`
	ServerKey  string `yaml:"server_key"`
	CACert     string `yaml:"ca_cert"`
}

func LoadConfig() ServerConfig {
	configPath := os.Getenv("{{.ConfigEnvVariable}}")
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		log.Fatalf(
			"Error loading config from {{.ConfigEnvVariable}}=%s: %v",
			configPath,
			err,
		)
	}

	config := ServerConfig{}
	err = yaml.Unmarshal([]byte(content), &config)
	if err != nil {
		log.Fatalf("Error parsing config: %v", err)
	}
	return config
}

func NewServerFromConfig(cfg ServerConfig) *Server {
	storage, err := NewPostgreStorage(cfg.DatabaseURI)
	if err != nil {
		log.Fatalf("Could not create storage: %v", err)
	}

	return &Server{
		storage: storage,
	}
}

func getTransportCredentials(cfg ServerConfig) (*credentials.TransportCredentials, error) {
	peerCert, err := tls.LoadX509KeyPair(cfg.ServerCert, cfg.ServerKey)
	if err != nil {
		return nil, err
	}

	caCert, err := ioutil.ReadFile(cfg.CACert)
	if err != nil {
		return nil, err
	}

	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)
	tc := credentials.NewTLS(&tls.Config{
		Certificates: []tls.Certificate{peerCert},
		ClientCAs:    caCertPool,
	})

	return &tc, nil
}
